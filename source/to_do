/* ***************************************************
typedef struct mutex                                 |
{                                                    |
	pthread_mutex_t	output;                          |     
	pthread_mutex_t	*forks;                          |     
}					t_mutex;                         |      
													 |
typedef struct data                                  |
{                                                    |
	long	start_time;                              | 
	int		dead;                                    |
	int		nb_of_philo;                             |  
	int		time_to_die;                             |  
	int		time_to_eat;                             |  
	int		time_to_sleep;                           |    
	int		nb_of_meals;                             |  
}			t_data;                                  |
													 |
typedef struct philo                                 |
{													 |
	int				philo_id;                        |       
	int				eat_count;                       |        
	long			last_meal;                       |        
	t_data			*args;                           |    
	t_mutex			*mutex;                          |     
	pthread_t		thread;                          |     
	pthread_mutex_t	*right_fork;                     |         
	pthread_mutex_t	*left_fork;                      |         
}					t_philo;                         |     
													 |
typedef struct all                                   |
{													 |
	t_mutex		*lock;                               |
	t_philo		*philo;                              |
	t_data		*data;                               |
}				t_all;                               | 
******************************************************
*/

//./philo <philo_nb> <time_die> <time_eat> <time_slp> [ <must_eat> ]
/*./philo 4 410 200 200
          +-|---|---|-- philo_nb
            +---|---|-- time_die
                +---|-- time_eat
                    +-- time_slp*/
//**************** Minimum time_die for EVEN philo_nb ****************
//	2 x time_eat + e

//**************** Minimum time_die for ODD philo_nb ****************
/*if time_eat >= time_slp

	3 * time_eat + e

if time_eat < time_slp

	time_eat + time_slp + e

420 200 -> 10:45 11:00 14 -> down 

*/


/*
int    if_dead(t_philo *philo)
{
    long    time;

    time = current_time() - philo->last_meal;
    if (time > philo->args->time_to_die)
    {
        pthread_mutex_lock(&philo->mutex->output);
        printf("%ld\tThe philo %d is dead\n",
            current_time() - philo->args->start_time, philo->philo_id);
        philo->args->dead = 1;
        return (1);
    }
    return (0);
}

int    check_death(t_all *info)
{
    int    i;
    int    count_meals;

    while (1)
    {
        i = 0;
        count_meals = 0;
        while (i < info->data->nb_of_philo)
        {
            if (if_dead(&info->philo[i]))
                return (1);
            count_meals += info->philo[i].eat_count;
            i++;
        }
        if (count_meals == 0)
        {
            pthread_mutex_lock(&info->lock->output);
            return (1);
        }
    }
    return (0);
}



int    if_dead(t_philo *philo)
{
    long    time;

    time = current_time() - philo->last_meal;
    if (time > philo->args->time_to_die)
    {
        pthread_mutex_lock(&philo->mutex->output);
        printf("%ld\tThe philo %d is dead\n",
            current_time() - philo->args->start_time, philo->philo_id);
        philo->args->dead = 1;
        return (1);
    }
    return (0);
}

int    check_death(t_all *info)
{
    int    i;
    int    count_meals;

    while (1)
    {
        i = 0;
        count_meals = 0;
        while (i < info->data->nb_of_philo)
        {
            if (if_dead(&info->philo[i]))
                return (1);
            count_meals += info->philo[i].eat_count;
            i++;
        }
        if (count_meals == 0)
        {
            pthread_mutex_lock(&info->lock->output);
            return (1);
        }
    }
    return (0);
}


int    make_thread(t_all *info, int j, int i)
{
    if (info->philo[i].philo_id % 2 == j)
    {
        if (pthread_create(&info->philo[i].thread, NULL,
                &routine, &info->philo[i]) != 0)
        {
            destroy_mutex(info);
            free(info->lock);
            free(info->lock->forks);
            return (1);
        }
    }
    usleep(30);
    return (0);
}

int    if_dead(t_philo *philo)
{
    long    time;

    time = current_time() - philo->last_meal;
    if (time > philo->args->time_to_die)
    {
        pthread_mutex_lock(&philo->mutex->output);
        printf("%ld\tThe philo %d is dead\n",
            current_time() - philo->args->start_time, philo->philo_id);
        philo->args->dead = 1;
        return (1);
    }
    return (0);
}

int    check_death(t_all *info)
{
    int    i;
    int    count_meals;

    while (1)
    {
        i = 0;
        count_meals = 0;
        while (i < info->data->nb_of_philo)
        {
            if (if_dead(&info->philo[i]))
                return (1);
            count_meals += info->philo[i].eat_count;
            i++;
        }
        if (count_meals == 0)
        {
            pthread_mutex_lock(&info->lock->output);
            return (1);
        }
    }
    return (0);
}

int    ft_threads(t_all *info)
{
    int    i;

    i = -1;
    info->data->start_time = current_time();
    while (++i < info->data->nb_of_philo)
        make_thread(info, 0, i);
    i = -1;
    while (++i < info->data->nb_of_philo)
        make_thread(info, 1, i);
    if (check_death(info))
        return (0);
    return (0);
}

}


void    output(t_philo *philo, char *str)
{
    pthread_mutex_lock(&philo->mutex->output);
    if (philo->args->dead == 1)
        return ;
    else if (philo->args->dead == 0)
    {
        printf("%ld\tThe philo %d %s\n",
            current_time() - philo->args->start_time, philo->philo_id, str);
        pthread_mutex_unlock(&philo->mutex->output);
    }
}

void    routine_2(t_philo *data)
{
    pthread_mutex_lock(data->right_fork);
    output(data, "has taken the right fork");
    pthread_mutex_lock(data->left_fork);
    output(data, "has taken the left fork");
    output(data, "is eating");
    data->last_meal = current_time();
    ft_sleep(data->args->time_to_eat);
    pthread_mutex_unlock(data->left_fork);
    pthread_mutex_unlock(data->right_fork);
    data->eat_count--;
    output(data, "is sleeping");
    ft_sleep(data->args->time_to_sleep);
    output(data, "is thinking");
}

void    *routine(void *data)
{
    t_philo    *philo;

    philo = (t_philo *)data;
    philo->last_meal = current_time();
    while (1)
    {
        if (philo->eat_count != 0)
            routine_2(philo);
        else
            break ;
    }
    return (NULL);
}

int    init_mutex(t_all *info)
{
    int    j;

    j = 0;
    info->lock = malloc(sizeof(t_mutex));
    if (!info->lock)
        return (1);
    info->lock->forks = malloc(sizeof(pthread_mutex_t)
            * info->data->nb_of_philo);
    if (!info->lock->forks)
        return (1);
    if (pthread_mutex_init(&info->lock->output, NULL) != 0)
        return (1);
    while (j < info->data->nb_of_philo)
    {
        if (pthread_mutex_init(&info->lock->forks[j], NULL) != 0)
            return (1);
        j++;
    }
    return (0);
}

int    init_philo(t_all *info)
{
    int    i;

    i = 0;
    info->philo = malloc(sizeof(t_philo) * info->data->nb_of_philo);
    if (!info->philo)
        return (1);
    while (i < info->data->nb_of_philo)
    {
        info->philo[i].philo_id = i + 1;
        info->philo[i].last_meal = 0;
        info->philo[i].eat_count = info->data->nb_of_meals;รง
        info->philo[i].args = info->data;
        info->philo[i].mutex = info->lock;
        info->philo[i].right_fork = &info->lock->forks[i];
        if ((i + 1) == info->data->nb_of_philo)
            info->philo[i].left_fork = &info->lock->forks[0];
        else
            info->philo[i].left_fork = &info->lock->forks[i + 1];
        i++;
    }
    return (0);
}

int    main(int ac, char **av)
{
    t_all    info;
    t_data    data;

    info.data = &data;
    if (ac < 5 || ac > 6)
        return (1);
    if (ft_parse(av))
        return (0);
    info.data->nb_of_philo = ft_atoi(av[1]);
    info.data->time_to_die = ft_atoi(av[2]);
    info.data->time_to_eat = ft_atoi(av[3]);
    info.data->time_to_sleep = ft_atoi(av[4]);
    info.data->nb_of_meals = -1;
    info.data->dead = 0;
    if (av[5] != NULL)
        info.data->nb_of_meals = ft_atoi(av[5]);
    if (init_mutex(&info))
        return (0);
    if (init_philo(&info))
        return (0);
    if (ft_threads(&info))
        return (0);
    free_and_destroy(&info);
    return (0);
}
*/